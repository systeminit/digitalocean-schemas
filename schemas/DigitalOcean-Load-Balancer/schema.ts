function main() {
    // DigitalOcean API Token secret
    const DOCredentialSecretProp = new SecretPropBuilder()
        .setName("DigitalOcean Credential")
        .setSecretKind("DigitalOcean Credential")
        .build();

    // Name property (required)
    const nameProp = new PropBuilder()
        .setName("name")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("text")
            .build())
        .setValidationFormat(Joi.string().required().max(255))
        .setDocumentation("A human-readable name for a load balancer instance.")
        .build();

    // Region property (required, CreateOnly)
    const regionProp = new PropBuilder()
        .setName("region")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("comboBox")
            .addOption("New York 1", "nyc1")
            .addOption("New York 3", "nyc3")
            .addOption("Amsterdam 3", "ams3")
            .addOption("San Francisco 3", "sfo3")
            .addOption("Singapore 1", "sgp1")
            .addOption("London 1", "lon1")
            .addOption("Frankfurt 1", "fra1")
            .addOption("Toronto 1", "tor1")
            .addOption("Bangalore 1", "blr1")
            .setCreateOnly()
            .build())
        .setValidationFormat(Joi.string().required())
        .setDocumentation("The slug identifier for the region where you want to deploy the load balancer.")
        .build();

    // Size Unit property (replaces deprecated size)
    const sizeUnitProp = new PropBuilder()
        .setName("size_unit")
        .setKind("float")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("text")
            .build())
        .setValidationFormat(Joi.number().integer().min(1).max(100).default(1))
        .setDocumentation("How many nodes the load balancer contains. Each additional node increases the load balancer's ability to manage more connections. Load balancers can be scaled up or down, and you can change the number of nodes after creation up to once per hour. This field is currently not available in the AMS2, NYC2, or SFO1 regions. Use the `size` field to scale load balancers that reside in these regions.")
        .build();

    // Size property (deprecated, for backward compatibility)
    const sizeProp = new PropBuilder()
        .setName("size")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("comboBox")
            .addOption("Small (1 node)", "lb-small")
            .addOption("Medium (3 nodes)", "lb-medium")
            .addOption("Large (6 nodes)", "lb-large")
            .build())
        .setValidationFormat(Joi.string().valid("lb-small", "lb-medium", "lb-large").default("lb-small"))
        .setDocumentation("This field has been replaced by the `size_unit` field for all regions except in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having a set number of nodes. * `lb-small` = 1 node * `lb-medium` = 3 nodes * `lb-large` = 6 nodes You can resize load balancers after creation up to once per hour. You cannot resize a load balancer within the first hour of its creation.")
        .build();

    // Algorithm property (deprecated)
    const algorithmProp = new PropBuilder()
        .setName("algorithm")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("comboBox")
            .addOption("Round Robin", "round_robin")
            .addOption("Least Connections", "least_connections")
            .build())
        .setValidationFormat(Joi.string().valid("round_robin", "least_connections").default("round_robin"))
        .setDocumentation("This field has been deprecated. You can no longer specify an algorithm for load balancers.")
        .build();

    // Project ID property
    const projectIdProp = new PropBuilder()
        .setName("project_id")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("text")
            .build())
        .setValidationFormat(Joi.string().uuid())
        .setDocumentation("The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project. If an invalid project ID is provided, the load balancer will not be created.")
        .build();

    // Droplet IDs array (for assigning by ID)
    const dropletIdsProp = new PropBuilder()
        .setName("droplet_ids")
        .setKind("array")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("array")
            .build())
        .setEntry(
            new PropBuilder()
                .setName("droplet_id")
                .setKind("float")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                .setValidationFormat(Joi.number().integer())
                .setDocumentation("Droplet ID")
                .build()
        )
        .setDocumentation("An array containing the IDs of the Droplets assigned to the load balancer.")
        .build();

    // Tag property (for assigning by tag)
    const tagProp = new PropBuilder()
        .setName("tag")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("text")
            .build())
        .setValidationFormat(Joi.string())
        .setDocumentation("The name of a Droplet tag corresponding to Droplets assigned to the load balancer.")
        .build();

    // Forwarding Rules array
    const forwardingRulesProp = new PropBuilder()
        .setName("forwarding_rules")
        .setKind("array")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("array")
            .build())
        .setEntry(
            new PropBuilder()
                .setName("forwarding_rule")
                .setKind("object")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("header").build())
                .addChild(
                    new PropBuilder()
                        .setName("entry_protocol")
                        .setKind("string")
                        .setWidget(new PropWidgetDefinitionBuilder()
                            .setKind("comboBox")
                            .addOption("HTTP", "http")
                            .addOption("HTTPS", "https")
                            .addOption("HTTP/2", "http2")
                            .addOption("HTTP/3", "http3")
                            .addOption("TCP", "tcp")
                            .addOption("UDP", "udp")
                            .build())
                        .setValidationFormat(Joi.string().valid("http", "https", "http2", "http3", "tcp", "udp").required())
                        .setDocumentation("The protocol used for traffic to the load balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`. If you set the `entry_protocol` to `udp`, the `target_protocol` must be set to `udp`. When using UDP, the load balancer requires that you set up a health check with a port that uses TCP, HTTP, or HTTPS to work properly.")
                        .build()
                )
                .addChild(
                    new PropBuilder()
                        .setName("entry_port")
                        .setKind("float")
                        .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                        .setValidationFormat(Joi.number().integer().min(1).max(65535).required())
                        .setDocumentation("An integer representing the port on which the load balancer instance will listen.")
                        .build()
                )
                .addChild(
                    new PropBuilder()
                        .setName("target_protocol")
                        .setKind("string")
                        .setWidget(new PropWidgetDefinitionBuilder()
                            .setKind("comboBox")
                            .addOption("HTTP", "http")
                            .addOption("HTTPS", "https")
                            .addOption("HTTP/2", "http2")
                            .addOption("TCP", "tcp")
                            .addOption("UDP", "udp")
                            .build())
                        .setValidationFormat(Joi.string().valid("http", "https", "http2", "tcp", "udp").required())
                        .setDocumentation("The protocol used for traffic from the load balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`. If you set the `target_protocol` to `udp`, the `entry_protocol` must be set to `udp`. When using UDP, the load balancer requires that you set up a health check with a port that uses TCP, HTTP, or HTTPS to work properly.")
                        .build()
                )
                .addChild(
                    new PropBuilder()
                        .setName("target_port")
                        .setKind("float")
                        .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                        .setValidationFormat(Joi.number().integer().min(1).max(65535).required())
                        .setDocumentation("An integer representing the port on the backend Droplets to which the load balancer will send traffic.")
                        .build()
                )
                .addChild(
                    new PropBuilder()
                        .setName("certificate_id")
                        .setKind("string")
                        .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                        .setValidationFormat(Joi.string())
                        .setDocumentation("The ID of the TLS certificate used for SSL termination if enabled.")
                        .build()
                )
                .addChild(
                    new PropBuilder()
                        .setName("tls_passthrough")
                        .setKind("boolean")
                        .setWidget(new PropWidgetDefinitionBuilder().setKind("checkbox").build())
                        .setValidationFormat(Joi.boolean().default(false))
                        .setDocumentation("A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets.")
                        .build()
                )
                .build()
        )
        .setDocumentation("An array of objects specifying the forwarding rules for a load balancer.")
        .build();

    // Health Check object
    const healthCheckProp = new PropBuilder()
        .setName("health_check")
        .setKind("object")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("header")
            .build())
        .addChild(
            new PropBuilder()
                .setName("protocol")
                .setKind("string")
                .setWidget(new PropWidgetDefinitionBuilder()
                    .setKind("comboBox")
                    .addOption("HTTP", "http")
                    .addOption("HTTPS", "https")
                    .addOption("TCP", "tcp")
                    .build())
                .setValidationFormat(Joi.string().valid("http", "https", "tcp").default("http"))
                .setDocumentation("The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https`, or `tcp`.")
                .build()
        )
        .addChild(
            new PropBuilder()
                .setName("port")
                .setKind("float")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                .setValidationFormat(Joi.number().integer().min(1).max(65535).default(80))
                .setDocumentation("An integer representing the port on the backend Droplets on which the health check will attempt a connection.")
                .build()
        )
        .addChild(
            new PropBuilder()
                .setName("path")
                .setKind("string")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                .setValidationFormat(Joi.string().default("/"))
                .setDocumentation("The path on the backend Droplets to which the load balancer instance will send a request.")
                .build()
        )
        .addChild(
            new PropBuilder()
                .setName("check_interval_seconds")
                .setKind("float")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                .setValidationFormat(Joi.number().integer().min(3).max(300).default(10))
                .setDocumentation("The number of seconds between between two consecutive health checks.")
                .build()
        )
        .addChild(
            new PropBuilder()
                .setName("response_timeout_seconds")
                .setKind("float")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                .setValidationFormat(Joi.number().integer().min(1).max(300).default(5))
                .setDocumentation("The number of seconds the load balancer instance will wait for a response until marking a health check as failed.")
                .build()
        )
        .addChild(
            new PropBuilder()
                .setName("unhealthy_threshold")
                .setKind("float")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                .setValidationFormat(Joi.number().integer().min(2).max(10).default(5))
                .setDocumentation("The number of times a health check must fail for a backend Droplet to be marked \"unhealthy\" and be removed from the pool.")
                .build()
        )
        .addChild(
            new PropBuilder()
                .setName("healthy_threshold")
                .setKind("float")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                .setValidationFormat(Joi.number().integer().min(2).max(10).default(3))
                .setDocumentation("The number of times a health check must pass for a backend Droplet to be marked \"healthy\" and be re-added to the pool.")
                .build()
        )
        .setDocumentation("An object specifying health check settings for the load balancer.")
        .build();

    // Sticky Sessions object
    const stickySessionsProp = new PropBuilder()
        .setName("sticky_sessions")
        .setKind("object")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("header")
            .build())
        .addChild(
            new PropBuilder()
                .setName("type")
                .setKind("string")
                .setWidget(new PropWidgetDefinitionBuilder()
                    .setKind("comboBox")
                    .addOption("None", "none")
                    .addOption("Cookies", "cookies")
                    .build())
                .setValidationFormat(Joi.string().valid("cookies", "none").default("none"))
                .setDocumentation("An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`.")
                .build()
        )
        .addChild(
            new PropBuilder()
                .setName("cookie_name")
                .setKind("string")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                .setValidationFormat(Joi.string())
                .setDocumentation("The name of the cookie sent to the client. This attribute is only returned when using `cookies` for the sticky sessions type.")
                .build()
        )
        .addChild(
            new PropBuilder()
                .setName("cookie_ttl_seconds")
                .setKind("float")
                .setWidget(new PropWidgetDefinitionBuilder().setKind("text").build())
                .setValidationFormat(Joi.number().integer().min(1))
                .setDocumentation("The number of seconds until the cookie set by the load balancer expires. This attribute is only returned when using `cookies` for the sticky sessions type.")
                .build()
        )
        .setDocumentation("An object specifying sticky sessions settings for the load balancer.")
        .build();

    // Redirect HTTP to HTTPS
    const redirectHttpToHttpsProp = new PropBuilder()
        .setName("redirect_http_to_https")
        .setKind("boolean")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("checkbox")
            .build())
        .setValidationFormat(Joi.boolean().default(false))
        .setDocumentation("A boolean value indicating whether HTTP requests to the load balancer on port 80 will be redirected to HTTPS on port 443.")
        .build();

    // Enable Proxy Protocol
    const enableProxyProtocolProp = new PropBuilder()
        .setName("enable_proxy_protocol")
        .setKind("boolean")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("checkbox")
            .build())
        .setValidationFormat(Joi.boolean().default(false))
        .setDocumentation("A boolean value indicating whether PROXY Protocol is in use.")
        .build();

    // Enable Backend Keepalive
    const enableBackendKeepaliveProp = new PropBuilder()
        .setName("enable_backend_keepalive")
        .setKind("boolean")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("checkbox")
            .build())
        .setValidationFormat(Joi.boolean().default(false))
        .setDocumentation("A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets.")
        .build();

    // HTTP Idle Timeout
    const httpIdleTimeoutSecondsProp = new PropBuilder()
        .setName("http_idle_timeout_seconds")
        .setKind("float")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("text")
            .build())
        .setValidationFormat(Joi.number().integer().min(30).max(600).default(60))
        .setDocumentation("An integer value which configures the idle timeout for HTTP requests to the target droplets.")
        .build();

    // VPC UUID (CreateOnly)
    const vpcUuidProp = new PropBuilder()
        .setName("vpc_uuid")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("text")
            .setCreateOnly()
            .build())
        .setValidationFormat(Joi.string().uuid())
        .setDocumentation("A string specifying the UUID of the VPC to which the load balancer is assigned.")
        .build();

    // Disable Let's Encrypt DNS records
    const disableLetsEncryptDnsRecordsProp = new PropBuilder()
        .setName("disable_lets_encrypt_dns_records")
        .setKind("boolean")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("checkbox")
            .build())
        .setValidationFormat(Joi.boolean().default(false))
        .setDocumentation("A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer.")
        .build();

    // Network (CreateOnly)
    const networkProp = new PropBuilder()
        .setName("network")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("comboBox")
            .addOption("External", "EXTERNAL")
            .addOption("Internal", "INTERNAL")
            .setCreateOnly()
            .build())
        .setValidationFormat(Joi.string().valid("EXTERNAL", "INTERNAL").default("EXTERNAL"))
        .setDocumentation("A string indicating whether the load balancer should be external or internal. Internal load balancers have no public IPs and are only accessible to resources on the same VPC network. This property cannot be updated after creating the load balancer.")
        .build();

    // Network Stack (CreateOnly)
    const networkStackProp = new PropBuilder()
        .setName("network_stack")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("comboBox")
            .addOption("IPv4", "IPV4")
            .addOption("IPv4 + IPv6", "DUALSTACK")
            .setCreateOnly()
            .build())
        .setValidationFormat(Joi.string().valid("IPV4", "DUALSTACK").default("IPV4"))
        .setDocumentation("A string indicating whether the load balancer will support IPv4 or both IPv4 and IPv6 networking. This property cannot be updated after creating the load balancer.")
        .build();

    // Type (CreateOnly)
    const typeProp = new PropBuilder()
        .setName("type")
        .setKind("string")
        .setHidden(false)
        .setWidget(new PropWidgetDefinitionBuilder()
            .setKind("comboBox")
            .addOption("Regional", "REGIONAL")
            .addOption("Regional Network", "REGIONAL_NETWORK")
            .addOption("Global", "GLOBAL")
            .setCreateOnly()
            .build())
        .setValidationFormat(Joi.string().valid("REGIONAL", "REGIONAL_NETWORK", "GLOBAL").default("REGIONAL"))
        .setDocumentation("A string indicating whether the load balancer should be a standard regional HTTP load balancer, a regional network load balancer that routes traffic at the TCP/UDP transport layer, or a global load balancer.")
        .build();


  const idProp = new PropBuilder()
    .setName("id")
    .setKind("string")
    .setHidden(false)
    .setWidget(new PropWidgetDefinitionBuilder()
      .setKind("text")
      .build())
    .build();

  const statusProp = new PropBuilder()
    .setName("status")
    .setKind("string")
    .setHidden(false)
    .setWidget(new PropWidgetDefinitionBuilder()
      .setKind("comboBox")
      .addOption("New", "new")
      .addOption("Active", "active")
      .addOption("Errored", "errored")
      .setCreateOnly()
      .build())
    .build();

  const createdAtProp = new PropBuilder()
    .setName("created_at")
    .setKind("string")
    .setHidden(false)
    .setWidget(new PropWidgetDefinitionBuilder()
      .setKind("text")
      .build())
    .build();


  // Create the asset
    const asset = new AssetBuilder()
        .addProp(nameProp)
        .addProp(regionProp)
        .addProp(sizeUnitProp)
        .addProp(sizeProp)
        .addProp(algorithmProp)
        .addProp(projectIdProp)
        .addProp(dropletIdsProp)
        .addProp(tagProp)
        .addProp(forwardingRulesProp)
        .addProp(healthCheckProp)
        .addProp(stickySessionsProp)
        .addProp(redirectHttpToHttpsProp)
        .addProp(enableProxyProtocolProp)
        .addProp(enableBackendKeepaliveProp)
        .addProp(httpIdleTimeoutSecondsProp)
        .addProp(vpcUuidProp)
        .addProp(disableLetsEncryptDnsRecordsProp)
        .addProp(networkProp)
        .addProp(networkStackProp)
        .addProp(typeProp)
        .addSecretProp(DOCredentialSecretProp)
        .addResourceProp(idProp)
        .addResourceProp(statusProp)
        .addResourceProp(createdAtProp)
        .build();

    return asset;
}